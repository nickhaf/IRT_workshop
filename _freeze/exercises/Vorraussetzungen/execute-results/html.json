{
  "hash": "44f14dd087c40f78a04a9ef48d3f4744",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"IRT Voraussetzungen\"\nauthor: \"Nicklas Hafiz\"\ndate: \"12 September, 2024\"\nformat: \n  html:\n    code-link: true\n---\n\n\n\n# Übung 1\n\nWir schauen uns eine ganz simple Version an. Wer interessiert ist, und z.B. Daten für eine Poweranalyse simulieren möchte, findet [hier]() Unterstützung.\n\n\n## Formel\nZuerst müssen wir festlegen, was wir eigentlich simulieren wollen. Wir starten mit einem 2PL Modell. Wie sah die Formel dafür noch einmal aus?\n\n\n$$\nP(X_{is} = 1|\\theta_s,\\beta_i,\\alpha_i) = \\frac{\\exp(\\alpha_i(\\theta_s-\\beta_i))}{1 + \\exp(a_i (\\theta_s - \\beta_i))}\n$$ {#eq-2PL}\n\n1. Versuche noch einmal, alle Elemente von @eq-2PL für dich selbst zu erklären.\n\n:::{.callout-caution collapse=true}\n## Lösung\n\nWir versuchen zu schätzen wie hoch die Wahrscheinlichkeit ist, dass eine Person $s$ ein Item $i$ richtig ($X_{is} = 1$) beantwortet. Dazu nutzen wir den Diskriminationsparameter $\\alpha_i$ und den Schwierigkeitsparameter $\\beta_i$ von Item $i$ und die Personenfähigkeit $\\theta_s$ von Person $s$.\n:::\n\n\n## 2PL Funktion\n2. Jetzt beginnt der fun part: Schreibe eine [Funktion]() genannt `calc_2pl` die genau diese Formel in R Code umsetzt. \n\n:::{.callout-tip collapse=true}\nDer Aufbau der Funktion könnte so aussehen:\n\n\n\n::: {.cell}\n\n:::\n\n\n\nBefülle sie nun mit der Formel. `alpha`, `theta` und `beta` sind hier also die Funktionsargumente (weil sie innerhalb der Klammern von `function()` stehen), und müssen beim späteren Aufruf der Funktion von der nutzenden Person mit Werten befüllt werden. Diese Werte können dann im Funktionskörper (zwischen `{}`) genutzt werden, um @eq-2PL in R Code zu übersetzen.\n\n:::\n\n\n:::{.callout-caution collapse=true}\n## Lösung\n\n\n::: {.cell}\n\n:::\n\n\n\n\n`alpha`, `theta` und `beta` sind hier also die Funktionsargumente (weil sie innerhalb der Klammern von `function()` stehen), und müssen beim späteren Aufruf der Funktion von der nutzenden Person mit Werten befüllt werden. Im Funktionskörper (zwischen `{}`) werden sie genutzt, um $p$ anhand von @eq-2PL zu berechnen.\n\n\n:::\n\n\n## Simulieren von Daten\nJetzt geht's los! Wir wollen nun eigene Daten simulieren. Das tolle ist: wir können so alle Aspekte selber festlegen, und daran untersuchen, wie sich das Variieren von bestimmten Parametern auf das Ergebnis auswirkt. \n\n\n### Items\n1. Zuerst die Items. Baue einen `data.frame` mit dem Namen `items`. Er soll 13 Zeilen und 4 Spalten haben und folgendes enthalten:\n\n- `id`: Die ID des Items, von 1 bis 13. \n- `alpha`: Die Diskriminationsparameter, liegen zwischen 0.5 und 1.5 in 13 gleich langen Schritten.\n- `beta`: Die Schwierigkeitsparameter, liegen zwischen -3 und 3 jeweils im Abstand von 0.5. \n\n:::{.callout-tip collapse=true}\n## Tip\n\nDie Funktion `seq()` ist dein Freund. Mehr brauchst du nicht, um die Zahlenreihen zu erzeugen. Schaue dir die Dokumentation an. \n\n:::\n\n:::{.callout-caution collapse=true}\n## Lösung\n\n\n::: {.cell}\n\n:::\n\n\n\nDas sind also die Itemparameter, die wir in unsere Simulation packen. \n:::\n\n\n2. Jetzt können wir die Personen simulieren. Unser Ziel ist also ein `data.frame`, der $\\theta$ Werte für die untersuchten Personen enthält. Wir simulieren 1000 Personen, der `data.frame` sollte also 1000 Zeilen haben. Außerdem benötigen wir zwei Spalten:\n\n- `person`: Die ID der Person, von 1 bis 1000.\n- `theta`: Die Fähigkeit der Person, die wir simulieren. Wir nehmen an, dass die Fähigkeit normalverteilt ist, mit einem Mittelwert von 0 und einer Standardabweichung von 1.\n\n:::{.callout-tip collapse=true}\n## Tip\nWir können zufällige Daten aus einer Normalverteilung mit Hilfe der Funktion `rnorm()` ziehen. \n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\n## Kalibrierte Parameter für 2 GLEICHE Gruppen\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n## Plot\n\n\n::: {.cell}\n\n:::\n\n\n\n\n## Kalibrierte Parameter für 2 versch. Gruppen\n\n\n::: {.cell}\n\n:::\n\n\n\n\n## Plot\n\n\n::: {.cell}\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}